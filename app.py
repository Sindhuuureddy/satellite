import streamlit as st
import ee
import json
import requests
import folium
from streamlit_folium import st_folium
from PIL import Image
from collections.abc import Mapping
import tempfile

st.set_page_config(page_title="Namma Kisan", layout="centered")

st.write("‚úÖ App is starting...")

try:
    with tempfile.NamedTemporaryFile(mode="w", delete=False, suffix=".json") as f:
        json.dump(dict(st.secrets["GOOGLE_APPLICATION_CREDENTIALS"]), f)
        f.flush()
        credentials = ee.ServiceAccountCredentials(None, f.name)
        ee.Initialize(credentials)
        st.success("üåç Earth Engine initialized successfully!")
except Exception as e:
    st.error(f"‚ùå Failed to initialize Earth Engine: {e}")
    st.stop()

st.write("üîç Ready for user input...")

def get_lat_lon(location_name):
    url = f"https://nominatim.openstreetmap.org/search?q={location_name}&format=json"
    headers = {"User-Agent": "MyApp"}
    try:
        response = requests.get(url, headers=headers).json()
        if response:
            return float(response[0]["lat"]), float(response[0]["lon"])
    except:
        return None, None
    return None, None

if "page" not in st.session_state:
    st.session_state.page = 1

if st.session_state.page == 1:
    st.title("üå± Namma Kisan - ‡≤®‡≤Æ‡≥ç‡≤Æ ‡≤∞‡≥à‡≤§")
    location = st.text_input("üìç Enter location (Kannada or English):")
    uploaded_image = st.file_uploader("üì∏ Upload a satellite image (optional):", type=["jpg", "jpeg", "png"])
    if location:
        st.session_state.location = location
        st.session_state.page = 2
        st.stop()

elif st.session_state.page == 2:
    location = st.session_state.location
    lat, lon = get_lat_lon(location)
    if lat and lon:
        st.session_state.lat = lat
        st.session_state.lon = lon
        st.success(f"üìå Location: {location}\nLatitude = {lat}, Longitude = {lon}")
        if st.button("‚û°Ô∏è Next: Soil Analysis"):
            st.session_state.page = 3
            st.stop()
    else:
        st.error("Could not retrieve coordinates. Try another location.")

elif st.session_state.page == 3:
    st.title("üß™ Soil & Crop Recommendation")
    lat, lon = st.session_state.lat, st.session_state.lon
    point = ee.Geometry.Point([lon, lat])

    image = ee.ImageCollection("COPERNICUS/S2_SR") \
        .filterBounds(point) \
        .filterDate('2023-01-01', '2023-12-31') \
        .sort("CLOUDY_PIXEL_PERCENTAGE") \
        .first()

    if image:
        # NDVI health visualization
        ndvi_health = image.normalizedDifference(['B8', 'B4']).rename("NDVI")
        ndvi_vis = {"min": 0.0, "max": 1.0, "palette": ['red', 'yellow', 'green']}

        ndvi_map = folium.Map(location=[lat, lon], zoom_start=13, control_scale=True)
        ndvi_map.add_ee_layer = add_ee_layer
        ndvi_map.add_ee_layer(ndvi_health, ndvi_vis, 'NDVI Vegetation Health')

        st.markdown("**üåø NDVI Vegetation Health / ‡≤∏‡≤∏‡≥ç‡≤Ø‡≤æ‡≤µ‡≤∞‡≤£‡≤¶ ‡≤Ü‡≤∞‡≥ã‡≤ó‡≥ç‡≤Ø:**")
        st_folium(ndvi_map, width=700, height=350)

        # Land Use / Land Cover (LULC) Change Detection
        lulc_early = ee.ImageCollection("ESA/WorldCover/v100").filterDate('2020-01-01', '2020-12-31').first()
        lulc_recent = ee.ImageCollection("ESA/WorldCover/v100").filterDate('2023-01-01', '2023-12-31').first()

        lulc_diff = lulc_recent.subtract(lulc_early).clip(point.buffer(1000))
        lulc_vis = {"min": -100, "max": 100, "palette": ['red', 'white', 'green']}

        lulc_map = folium.Map(location=[lat, lon], zoom_start=13, control_scale=True)
        lulc_map.add_ee_layer = add_ee_layer
        lulc_map.add_ee_layer(lulc_diff, lulc_vis, 'LULC Change Detection')

        st.markdown("**üó∫Ô∏è Land Use / Land Cover Change (2020 ‚Üí 2023) / ‡≤≠‡≥Ç‡≤™‡≤Ø‡≥ã‡≤ó ‡≤¨‡≤¶‡≤≤‡≤æ‡≤µ‡≤£‡≥Ü:**")
        st_folium(lulc_map, width=700, height=350)
        ndvi = image.normalizedDifference(['B8', 'B4'])
        ndwi = image.normalizedDifference(['B3', 'B8'])
        ndbi = image.normalizedDifference(['B11', 'B8'])
        classified = ee.Image(0) \
            .where(ndvi.gt(0.2), 1) \
            .where(ndwi.gt(0.1), 2) \
            .where(ndbi.gt(0.1), 3) \
            .where(ndvi.lt(0).And(ndwi.lt(0)).And(ndbi.lt(0)), 4)

        def add_ee_layer(self, ee_image, vis_params, name):
            map_id_dict = ee.Image(ee_image).getMapId(vis_params)
            folium.raster_layers.TileLayer(
                tiles=map_id_dict["tile_fetcher"].url_format,
                attr="Google Earth Engine",
                name=name,
                overlay=True,
                control=True,
            ).add_to(self)

        folium.Map.add_ee_layer = add_ee_layer

        original_map = folium.Map(location=[lat, lon], zoom_start=13, control_scale=True)
        segmented_map = folium.Map(location=[lat, lon], zoom_start=13, control_scale=True)

        original_map.add_ee_layer(image.visualize(min=0, max=3000, bands=['B4','B3','B2']), {}, "Original Image")
        segmented_map.add_ee_layer(classified.visualize(min=0, max=4, palette=['black', 'green', 'blue', 'gray', 'yellow']), {}, "Segmented")

        col1, col2 = st.columns(2)
        with col1:
            st.write("üõ∞Ô∏è Original Satellite Image")
            st_folium(original_map, width=340, height=350)
        with col2:
            st.write("üó∫Ô∏è Segmented Land Cover")
            st_folium(segmented_map, width=340, height=350)

        # Building presence and classification
        building_mask = classified.eq(3)
        building_density = building_mask.reduceRegion(
            reducer=ee.Reducer.mean(),
            geometry=point.buffer(1000),
            scale=30
        ).getInfo()

        density_value = building_density.get('constant') if building_density else None

        building_type = "Unknown"
        if density_value:
            if density_value > 0.3:
                building_type = "üè¢ Apartments / ‡≤Ö‡≤™‡≤æ‡≤∞‡≥ç‡≤ü‡≥ç‚Äå‡≤Æ‡≥Ü‡≤Ç‡≤ü‡≥ç‚Äå‡≤ó‡≤≥‡≥Å"
            elif 0.1 < density_value <= 0.3:
                building_type = "üèòÔ∏è Rental Houses / ‡≤¨‡≤æ‡≤°‡≤ø‡≤ó‡≥Ü ‡≤Æ‡≤®‡≥Ü‡≤ó‡≤≥‡≥Å"
            elif 0 < density_value <= 0.1:
                building_type = "üè† Own House / ‡≤ñ‡≤æ‡≤∏‡≤ó‡≤ø ‡≤Æ‡≤®‡≥Ü"

        st.write(f"**üèóÔ∏è Building Type (Estimated) / ‡≤ï‡≤ü‡≥ç‡≤ü‡≤°‡≤¶ ‡≤™‡≥ç‡≤∞‡≤ï‡≤æ‡≤∞ (‡≤Ö‡≤Ç‡≤¶‡≤æ‡≤ú‡≥Å):** {building_type}")

    else:
        st.error("‚ùå No Sentinel-2 image found for this location and date range.")

    soil_dataset = ee.Image('OpenLandMap/SOL/SOL_TEXTURE-CLASS_USDA-TT_M/v02')
    soil_texture = soil_dataset.select('b0')
    soil_value = soil_texture.reduceRegion(reducer=ee.Reducer.mode(), geometry=point, scale=250).getInfo()

    soil_type = "Unknown"
    if soil_value:
        soil_class = soil_value.get("b0")
        if soil_class in [1, 2]:
            soil_type = "Sandy Soil / ‡≤Æ‡≤∞‡≤≥‡≥Å ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å"
        elif soil_class in [3, 4]:
            soil_type = "Loamy Soil / ‡≤Æ‡≤ø‡≤∂‡≥ç‡≤∞ ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å"
        elif soil_class in [5, 6]:
            soil_type = "Clayey Soil / ‡≤ï‡≤°‡≤≤‡≥Å ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å"

    crops = {
        "Sandy Soil / ‡≤Æ‡≤∞‡≤≥‡≥Å ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "Carrots, Peanuts, Watermelon / ‡≤ó‡≤æ‡≤ú‡≤∞‡≤ø‡≤ó‡≤≥‡≥Å, ‡≤∂‡≥á‡≤Ç‡≤ó‡≤æ, ‡≤ï‡≤≤‡≤Ç‡≤ó‡≤°‡≤ø‡≤ó‡≤≥‡≥Å",
        "Loamy Soil / ‡≤Æ‡≤ø‡≤∂‡≥ç‡≤∞ ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "Wheat, Maize, Vegetables / ‡≤ó‡≥ã‡≤ß‡≤ø, ‡≤ú‡≥ã‡≤≥, ‡≤§‡≤∞‡≤ï‡≤æ‡≤∞‡≤ø‡≤ó‡≤≥‡≥Å",
        "Clayey Soil / ‡≤ï‡≤°‡≤≤‡≥Å ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "Rice, Sugarcane, Pulses / ‡≤Ö‡≤ï‡≥ç‡≤ï‡≤ø, ‡≤∏‡≤ï‡≥ç‡≤ï‡≤∞‡≥Ü, ‡≤ï‡≤°‡≤≤‡≥Ü"
    }

    rainfall = {
        "Sandy Soil / ‡≤Æ‡≤∞‡≤≥‡≥Å ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "300‚Äì600 mm (Low to Moderate)",
        "Loamy Soil / ‡≤Æ‡≤ø‡≤∂‡≥ç‡≤∞ ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "600‚Äì1000 mm (Moderate)",
        "Clayey Soil / ‡≤ï‡≤°‡≤≤‡≥Å ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "1000+ mm (High)"
    }

    moisture = {
        "Sandy Soil / ‡≤Æ‡≤∞‡≤≥‡≥Å ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "Low",
        "Loamy Soil / ‡≤Æ‡≤ø‡≤∂‡≥ç‡≤∞ ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "Moderate",
        "Clayey Soil / ‡≤ï‡≤°‡≤≤‡≥Å ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å": "High"
    }

    st.write(f"**üü§ Soil Type / ‡≤Æ‡≤£‡≥ç‡≤£‡≥Å ‡≤™‡≥ç‡≤∞‡≤ï‡≤æ‡≤∞:** {soil_type}")
    st.write(f"**üåæ Recommended Crops / ‡≤∂‡≤ø‡≤´‡≤æ‡≤∞‡≤∏‡≥Å ‡≤Æ‡≤æ‡≤°‡≤ø‡≤¶ ‡≤¨‡≥Ü‡≤≥‡≥Ü‡≤ó‡≤≥‡≥Å:** {crops.get(soil_type, 'N/A')}")
    st.write(f"**üåßÔ∏è Rainfall Required / ‡≤Ö‡≤ó‡≤§‡≥ç‡≤Ø‡≤µ‡≤ø‡≤∞‡≥Å‡≤µ ‡≤Æ‡≤≥‡≥Ü‡≤Ø ‡≤™‡≥ç‡≤∞‡≤Æ‡≤æ‡≤£:** {rainfall.get(soil_type, 'N/A')}")
    st.write(f"**üíß Moisture Content / ‡≤§‡≥á‡≤µ‡≤æ‡≤Ç‡≤∂‡≤¶ ‡≤Æ‡≤ü‡≥ç‡≤ü:** {moisture.get(soil_type, 'N/A')}")

    if st.button("‚û°Ô∏è Next: Water Analysis"):
        st.session_state.page = 4
        st.stop()

elif st.session_state.page == 4:
    st.title("üíß Water Body Detection")
    lat, lon = st.session_state.lat, st.session_state.lon
    point = ee.Geometry.Point([lon, lat])

    modis_water = ee.ImageCollection("MODIS/006/MOD44W").mosaic().select("water_mask")
    modis_presence = modis_water.reduceRegion(reducer=ee.Reducer.mean(), geometry=point.buffer(1000), scale=250).get("water_mask").getInfo()

    if modis_presence and modis_presence > 0:
        st.success("‚úÖ Water body detected in this region. / ‡≤à ‡≤™‡≥ç‡≤∞‡≤¶‡≥á‡≤∂‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤®‡≥Ä‡≤∞‡≤ø‡≤® ‡≤®‡≤ø‡≤ï‡≥ç‡≤∑‡≥á‡≤™ ‡≤™‡≤§‡≥ç‡≤§‡≥Ü‡≤Ø‡≤æ‡≤ó‡≤ø‡≤¶‡≥Ü.")

    # Water Quality Indicators (Pollution & Fish Feasibility)
    water_quality = ee.ImageCollection("ECMWF/ERA5_LAND/MONTHLY") \
        .filterBounds(point) \
        .select(["lake_total_layer_temperature", "lake_mix_layer_depth", "lake_bottom_temperature"]) \
        .mean()

    quality_data = water_quality.reduceRegion(
        reducer=ee.Reducer.mean(),
        geometry=point.buffer(1000),
        scale=500,
        maxPixels=1e13
    ).getInfo()

    temp = quality_data.get("lake_total_layer_temperature")
    depth = quality_data.get("lake_mix_layer_depth")

    pollution_status = "Moderate"
    if temp and temp > 305:
        pollution_status = "High / ‡≤π‡≥Ü‡≤ö‡≥ç‡≤ö‡≤ø‡≤® ‡≤Æ‡≤æ‡≤≤‡≤ø‡≤®‡≥ç‡≤Ø"
    elif temp and temp < 295:
        pollution_status = "Low / ‡≤ï‡≤°‡≤ø‡≤Æ‡≥Ü ‡≤Æ‡≤æ‡≤≤‡≤ø‡≤®‡≥ç‡≤Ø"

    fishing_possible = "Yes / ‡≤π‡≥å‡≤¶‡≥Å" if depth and depth > 0.5 else "No / ‡≤á‡≤≤‡≥ç‡≤≤"

    st.markdown(f"**üåä Water Pollution Estimate / ‡≤®‡≥Ä‡≤∞‡≤ø‡≤® ‡≤Æ‡≤æ‡≤≤‡≤ø‡≤®‡≥ç‡≤Ø ‡≤™‡≥ç‡≤∞‡≤Æ‡≤æ‡≤£:** {pollution_status}")
    st.markdown(f"**üêü Fishery Possibility / ‡≤Æ‡≥Ä‡≤®‡≥Å‡≤ó‡≤æ‡≤∞‡≤ø‡≤ï‡≥Ü ‡≤∏‡≤æ‡≤ß‡≥ç‡≤Ø‡≤§‡≥Ü:** {fishing_possible}")
    else:
        st.warning("‚ö†Ô∏è No water body detected in this area. / ‡≤à ‡≤™‡≥ç‡≤∞‡≤¶‡≥á‡≤∂‡≤¶‡≤≤‡≥ç‡≤≤‡≤ø ‡≤Ø‡≤æ‡≤µ‡≥Å‡≤¶‡≥á ‡≤®‡≥Ä‡≤∞‡≤ø‡≤® ‡≤®‡≤ø‡≤ï‡≥ç‡≤∑‡≥á‡≤™ ‡≤™‡≤§‡≥ç‡≤§‡≥Ü‡≤Ø‡≤æ‡≤ó‡≤ø‡≤≤‡≥ç‡≤≤.")
        st.info("üí° Suggested Irrigation / ‡≤∂‡≤ø‡≤´‡≤æ‡≤∞‡≤∏‡≥Å ‡≤Æ‡≤æ‡≤°‡≤ø‡≤¶ ‡≤®‡≤ø‡≥ï‡≤∞‡≤æ‡≤µ‡≤∞‡≤ø: Borewell (‡≤¨‡≥ã‡≤∞‡≥ç‚Äå‡≤µ‡≥Ü‡≤≤‡≥ç), Drip (‡≤ü‡≤™‡≤ï ‡≤®‡≥Ä‡≤∞‡≤æ‡≤µ‡≤∞‡≤ø), Rainwater Harvesting (‡≤Æ‡≤≥‡≥Ü ‡≤®‡≥Ä‡≤∞‡≤ø‡≤® ‡≤∏‡≤Ç‡≤ó‡≥ç‡≤∞‡≤π‡≤£‡≥Ü)")

    if st.button("üîÅ Restart"):
        st.session_state.page = 1
        st.stop()

if "uploaded_image" in locals() and uploaded_image:
    st.image(Image.open(uploaded_image), caption="Uploaded Satellite Image", use_column_width=True)
    st.info("üñºÔ∏è You uploaded a custom satellite image.")
